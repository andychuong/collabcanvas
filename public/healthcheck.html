<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Health Check - Collab Canvas</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 24px;
      max-width: 800px;
      width: 100%;
    }

    h1 {
      color: #1a202c;
      font-size: 28px;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .subtitle {
      color: #718096;
      font-size: 13px;
      margin-bottom: 20px;
    }

    .overall-status {
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 20px;
      text-align: center;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .overall-status.healthy {
      background: #c6f6d5;
      color: #22543d;
      border: 2px solid #48bb78;
    }

    .overall-status.degraded {
      background: #fef5e7;
      color: #975a16;
      border: 2px solid #f6ad55;
    }

    .overall-status.down {
      background: #fed7d7;
      color: #742a2a;
      border: 2px solid #f56565;
    }

    .overall-status.checking {
      background: #e6fffa;
      color: #234e52;
      border: 2px solid #4fd1c5;
    }

    .service {
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      transition: all 0.3s ease;
    }

    .service:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      transform: translateY(-2px);
    }

    .service-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      cursor: pointer;
      user-select: none;
      transition: margin-bottom 0.3s ease;
    }

    .service-header.collapsed {
      margin-bottom: 0;
    }


    .service-name {
      font-size: 16px;
      font-weight: 600;
      color: #2d3748;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: color 0.2s ease;
    }

    .service-header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toggle-icon {
      width: 20px;
      height: 20px;
      color: #718096;
      transition: transform 0.3s ease;
    }

    .toggle-icon.collapsed {
      transform: rotate(-90deg);
    }

    .status-badge {
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-badge.healthy {
      background: #c6f6d5;
      color: #22543d;
    }

    .status-badge.checking {
      background: #e6fffa;
      color: #234e52;
    }

    .status-badge.error {
      background: #fed7d7;
      color: #742a2a;
    }

    .service-details {
      color: #718096;
      font-size: 14px;
      line-height: 1.6;
      max-height: 500px;
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease;
      opacity: 1;
    }

    .service-details.collapsed {
      max-height: 0;
      opacity: 0;
      margin-bottom: 0;
    }

    .service-details .detail-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
    }

    .service-details .detail-label {
      font-weight: 500;
    }

    .service-details .detail-value {
      font-family: 'Courier New', monospace;
      color: #4a5568;
    }

    .refresh-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      width: 100%;
      margin-top: 16px;
    }

    .refresh-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 16px rgba(102, 126, 234, 0.3);
    }

    .refresh-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .timestamp {
      text-align: center;
      color: #a0aec0;
      font-size: 12px;
      margin-top: 16px;
    }

    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #e2e8f0;
      border-top-color: #667eea;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .icon {
      width: 24px;
      height: 24px;
    }

    .error-details {
      margin-top: 8px;
      padding: 12px;
      background: #fff5f5;
      border-left: 4px solid #f56565;
      border-radius: 4px;
      font-size: 13px;
      color: #742a2a;
      font-family: 'Courier New', monospace;
    }

    .test-suite {
      margin-top: 12px;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      padding: 16px;
      background: #f7fafc;
    }

    .test-suite-header {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .test-case {
      padding: 10px;
      margin-bottom: 6px;
      border-radius: 8px;
      background: white;
      border-left: 4px solid #cbd5e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
    }

    .test-case.passed {
      border-left-color: #48bb78;
      background: #f0fff4;
    }

    .test-case.failed {
      border-left-color: #f56565;
      background: #fff5f5;
    }

    .test-case.running {
      border-left-color: #4fd1c5;
      background: #e6fffa;
    }

    .test-badge {
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .test-badge.passed {
      background: #c6f6d5;
      color: #22543d;
    }

    .test-badge.failed {
      background: #fed7d7;
      color: #742a2a;
    }

    .test-badge.running {
      background: #b2f5ea;
      color: #234e52;
    }

    .test-summary {
      margin-top: 12px;
      padding: 12px;
      border-radius: 8px;
      background: white;
      border: 2px solid #e2e8f0;
      font-weight: 600;
      font-size: 15px;
    }

    .test-summary.all-passed {
      background: #c6f6d5;
      border-color: #48bb78;
      color: #22543d;
    }

    .test-summary.some-failed {
      background: #fed7d7;
      border-color: #f56565;
      color: #742a2a;
    }

    .test-error {
      margin-top: 8px;
      padding: 8px;
      background: #fff5f5;
      border-radius: 4px;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      color: #742a2a;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>
      <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
      </svg>
      Health Check
    </h1>
    <div class="subtitle">Real-time status monitoring for Collab Canvas services</div>

    <div id="overall-status" class="overall-status checking">
      <div class="spinner"></div> Checking system health...
    </div>

    <div id="services"></div>

    <button id="refresh-btn" class="refresh-btn" onclick="checkHealth()">
      <span id="btn-text">Refresh Status</span>
    </button>

    <button id="run-tests-btn" class="refresh-btn" onclick="runTests()" style="margin-top: 12px; background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);">
      <span id="test-btn-text">🧪 Run Integration Tests</span>
    </button>

    <div id="test-results" style="margin-top: 24px; display: none;"></div>

    <div class="timestamp" id="timestamp"></div>
  </div>

  <script type="module">
    // Import Firebase
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
    import { getAuth, connectAuthEmulator } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
    import { getFirestore, connectFirestoreEmulator, collection, getDocs, limit, query } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js';
    import { getDatabase, ref, set, get, remove } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js';

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyB-3j0vC4OIHT2WVs1dD_WKE7jVp-mRHf8",
      authDomain: "collabcanvas-andy.firebaseapp.com",
      projectId: "collabcanvas-andy",
      storageBucket: "collabcanvas-andy.firebasestorage.app",
      messagingSenderId: "646326990612",
      appId: "1:646326990612:web:d90feb73b6cc3ed03d4c7e",
      databaseURL: "https://collabcanvas-andy-default-rtdb.firebaseio.com"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const realtimeDb = getDatabase(app);

    let services = [];

    async function checkFirebaseAuth() {
      const startTime = Date.now();
      try {
        // Check if auth is configured and operational
        const currentUser = auth.currentUser;
        const latency = Date.now() - startTime;
        
        return {
          name: 'Firebase Authentication',
          status: 'healthy',
          details: [
            { label: 'Response Time', value: `${latency}ms` },
            { label: 'Status', value: 'Operational' },
            { label: 'Service', value: 'Available' },
          ]
        };
      } catch (error) {
        return {
          name: 'Firebase Authentication',
          status: 'error',
          details: [
            { label: 'Status', value: 'Error' },
            { label: 'Error', value: error.message }
          ],
          error: error.message
        };
      }
    }

    async function checkFirestore() {
      const startTime = Date.now();
      try {
        // Try to read from groups collection
        const groupsRef = collection(db, 'groups');
        const q = query(groupsRef, limit(1));
        await getDocs(q);
        
        const latency = Date.now() - startTime;
        
        return {
          name: 'Cloud Firestore',
          status: 'healthy',
          details: [
            { label: 'Response Time', value: `${latency}ms` },
            { label: 'Status', value: 'Operational' },
            { label: 'Database', value: 'Connected' },
          ]
        };
      } catch (error) {
        const latency = Date.now() - startTime;
        
        // If it's a permissions error, the database is actually working - just requires auth
        if (error.code === 'permission-denied' || error.message.includes('Missing or insufficient permissions')) {
          return {
            name: 'Cloud Firestore',
            status: 'healthy',
            details: [
              { label: 'Response Time', value: `${latency}ms` },
              { label: 'Status', value: 'Operational' },
              { label: 'Database', value: 'Connected' },
              { label: 'Security', value: 'Rules enforced (auth required)' },
            ]
          };
        }
        
        return {
          name: 'Cloud Firestore',
          status: 'error',
          details: [
            { label: 'Status', value: 'Error' },
            { label: 'Error', value: error.message }
          ],
          error: error.message
        };
      }
    }

    async function checkFirebaseHosting() {
      const startTime = Date.now();
      try {
        // Check if we can load the main app
        const response = await fetch('/');
        const latency = Date.now() - startTime;
        
        return {
          name: 'Firebase Hosting',
          status: response.ok ? 'healthy' : 'error',
          details: [
            { label: 'Response Time', value: `${latency}ms` },
            { label: 'Status Code', value: response.status },
            { label: 'Status', value: response.ok ? 'Operational' : 'Error' },
          ]
        };
      } catch (error) {
        return {
          name: 'Firebase Hosting',
          status: 'error',
          details: [
            { label: 'Status', value: 'Error' },
            { label: 'Error', value: error.message }
          ],
          error: error.message
        };
      }
    }

    async function checkRealtimeDatabase() {
      const startTime = Date.now();
      try {
        // Try to write and read a test value
        const testRef = ref(realtimeDb, '_healthcheck/test');
        const testValue = { timestamp: Date.now(), test: true };
        
        await set(testRef, testValue);
        const snapshot = await get(testRef);
        await remove(testRef); // Clean up
        
        const latency = Date.now() - startTime;
        
        if (snapshot.exists()) {
          return {
            name: 'Realtime Database',
            status: 'healthy',
            details: [
              { label: 'Response Time', value: `${latency}ms` },
              { label: 'Status', value: 'Operational' },
              { label: 'Read/Write', value: 'Working' },
              { label: 'Usage', value: 'Cursors & Presence' },
            ]
          };
        } else {
          return {
            name: 'Realtime Database',
            status: 'error',
            details: [
              { label: 'Status', value: 'Error' },
              { label: 'Error', value: 'Write succeeded but read failed' }
            ],
            error: 'Write succeeded but read failed'
          };
        }
      } catch (error) {
        const latency = Date.now() - startTime;
        
        // Permission errors mean the database is working, just protected
        if (error.code === 'PERMISSION_DENIED' || error.message.includes('permission')) {
          return {
            name: 'Realtime Database',
            status: 'healthy',
            details: [
              { label: 'Response Time', value: `${latency}ms` },
              { label: 'Status', value: 'Operational' },
              { label: 'Database', value: 'Connected' },
              { label: 'Security', value: 'Rules enforced (auth required)' },
            ]
          };
        }
        
        return {
          name: 'Realtime Database',
          status: 'error',
          details: [
            { label: 'Status', value: 'Error' },
            { label: 'Error', value: error.message }
          ],
          error: error.message
        };
      }
    }

    async function checkOpenAIAPI() {
      try {
        const apiKey = localStorage.getItem('openai_api_key');
        
        if (!apiKey) {
          return {
            name: 'OpenAI API (AI Assistant)',
            status: 'healthy',
            details: [
              { label: 'Status', value: 'Not Configured' },
              { label: 'Note', value: 'API key not set by user' },
              { label: 'Feature', value: 'Optional - AI chat disabled' },
            ]
          };
        }

        // Test the API key with a minimal request
        try {
          const testStartTime = Date.now();
          const response = await fetch('https://api.openai.com/v1/models', {
            method: 'GET',
            headers: {
              'Authorization': `Bearer ${apiKey}`,
            },
          });
          const testLatency = Date.now() - testStartTime;

          if (response.ok) {
            return {
              name: 'OpenAI API (AI Assistant)',
              status: 'healthy',
              details: [
                { label: 'Response Time', value: `${testLatency}ms` },
                { label: 'Status', value: 'Operational' },
                { label: 'API Key', value: `${apiKey.substring(0, 12)}...` },
                { label: 'Authentication', value: 'Valid' },
              ]
            };
          } else if (response.status === 401) {
            return {
              name: 'OpenAI API (AI Assistant)',
              status: 'error',
              details: [
                { label: 'Status', value: 'Authentication Failed' },
                { label: 'API Key', value: `${apiKey.substring(0, 12)}...` },
                { label: 'Error', value: 'Invalid API key' }
              ],
              error: 'Invalid or expired API key'
            };
          } else {
            return {
              name: 'OpenAI API (AI Assistant)',
              status: 'error',
              details: [
                { label: 'Status', value: 'Error' },
                { label: 'HTTP Status', value: response.status.toString() },
                { label: 'Error', value: response.statusText }
              ],
              error: `HTTP ${response.status}: ${response.statusText}`
            };
          }
        } catch (fetchError) {
          return {
            name: 'OpenAI API (AI Assistant)',
            status: 'error',
            details: [
              { label: 'Status', value: 'Connection Error' },
              { label: 'Error', value: fetchError.message }
            ],
            error: fetchError.message
          };
        }
      } catch (error) {
        return {
          name: 'OpenAI API (AI Assistant)',
          status: 'error',
          details: [
            { label: 'Status', value: 'Error' },
            { label: 'Error', value: error.message }
          ],
          error: error.message
        };
      }
    }

    function renderServices() {
      const container = document.getElementById('services');
      container.innerHTML = services.map((service, index) => `
        <div class="service">
          <div class="service-header collapsed" data-service-index="${index}">
            <div class="service-name">
              ${service.status === 'checking' ? '<div class="spinner"></div>' : ''}
              ${service.name}
            </div>
            <div class="service-header-right">
              <span class="status-badge ${service.status}">
                ${service.status === 'checking' ? 'Checking...' : service.status}
              </span>
              <svg class="toggle-icon collapsed" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
              </svg>
            </div>
          </div>
          <div class="service-details collapsed" data-service-details="${index}">
            ${service.details.map(detail => `
              <div class="detail-row">
                <span class="detail-label">${detail.label}:</span>
                <span class="detail-value">${detail.value}</span>
              </div>
            `).join('')}
          </div>
          ${service.error ? `<div class="error-details">${service.error}</div>` : ''}
        </div>
      `).join('');
      
      // Add click handlers for toggle
      document.querySelectorAll('.service-header').forEach(header => {
        header.addEventListener('click', (e) => {
          const index = e.currentTarget.getAttribute('data-service-index');
          const details = document.querySelector(`[data-service-details="${index}"]`);
          const icon = e.currentTarget.querySelector('.toggle-icon');
          
          details.classList.toggle('collapsed');
          icon.classList.toggle('collapsed');
          e.currentTarget.classList.toggle('collapsed');
        });
      });
    }

    function updateOverallStatus() {
      const overallDiv = document.getElementById('overall-status');
      const healthyCount = services.filter(s => s.status === 'healthy').length;
      const errorCount = services.filter(s => s.status === 'error').length;
      const checkingCount = services.filter(s => s.status === 'checking').length;

      if (checkingCount > 0) {
        overallDiv.className = 'overall-status checking';
        overallDiv.innerHTML = '<div class="spinner"></div> Checking system health...';
      } else if (errorCount === 0) {
        overallDiv.className = 'overall-status healthy';
        overallDiv.innerHTML = `✅ All Systems Operational (${healthyCount}/${services.length})`;
      } else if (errorCount < services.length) {
        overallDiv.className = 'overall-status degraded';
        overallDiv.innerHTML = `⚠️ Degraded Performance (${healthyCount}/${services.length} healthy)`;
      } else {
        overallDiv.className = 'overall-status down';
        overallDiv.innerHTML = `❌ System Down (${errorCount}/${services.length} errors)`;
      }
    }

    async function checkHealth() {
      const btn = document.getElementById('refresh-btn');
      const btnText = document.getElementById('btn-text');
      
      btn.disabled = true;
      btnText.textContent = 'Checking...';

      // Initialize services with checking status
      services = [
        { name: 'Firebase Authentication', status: 'checking', details: [] },
        { name: 'Cloud Firestore', status: 'checking', details: [] },
        { name: 'Realtime Database', status: 'checking', details: [] },
        { name: 'Firebase Hosting', status: 'checking', details: [] },
        { name: 'OpenAI API (AI Assistant)', status: 'checking', details: [] },
      ];

      renderServices();
      updateOverallStatus();

      // Check all services in parallel
      const results = await Promise.all([
        checkFirebaseAuth(),
        checkFirestore(),
        checkRealtimeDatabase(),
        checkFirebaseHosting(),
        checkOpenAIAPI(),
      ]);

      services = results;
      renderServices();
      updateOverallStatus();

      // Update timestamp
      const now = new Date();
      document.getElementById('timestamp').textContent = 
        `Last checked: ${now.toLocaleString()}`;

      btn.disabled = false;
      btnText.textContent = 'Refresh Status';
    }

    // Run check on page load
    window.checkHealth = checkHealth;
    checkHealth();

    // Auto-refresh every 30 seconds
    setInterval(checkHealth, 30000);

    // Test Runner
    let testResults = [];

    async function runTests() {
      const btn = document.getElementById('run-tests-btn');
      const btnText = document.getElementById('test-btn-text');
      const resultsDiv = document.getElementById('test-results');
      
      btn.disabled = true;
      btnText.textContent = '⏳ Running Tests...';
      resultsDiv.style.display = 'block';
      resultsDiv.innerHTML = '<div class="spinner"></div> Initializing test suite...';
      
      testResults = [];
      
      try {
        // Run all test suites
        await runUtilityTests();
        await runShapeOperationTests();
        await runIntegrationTests();
        await runDataValidationTests();
        
        // Display results
        displayTestResults();
      } catch (error) {
        resultsDiv.innerHTML = `<div class="error-details">Test suite failed: ${error.message}</div>`;
      }
      
      btn.disabled = false;
      btnText.textContent = '🧪 Run Integration Tests';
    }

    async function runShapeOperationTests() {
      const suite = { name: 'Shape Operations & Canvas Logic', tests: [] };
      
      // Helper: Create a test shape
      const createShape = (type, props = {}) => {
        const baseShape = {
          id: `test_${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          type,
          x: 100,
          y: 100,
          fill: '#000000',
          stroke: '#000000',
          strokeWidth: 2,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          userId: 'test_user'
        };
        
        // Add type-specific defaults, then override with custom props
        if (type === 'rectangle' || type === 'arrow') {
          return { ...baseShape, width: 100, height: 50, rotation: 0, ...props };
        } else if (type === 'circle') {
          return { ...baseShape, radius: 50, ...props };
        } else if (type === 'line') {
          return { ...baseShape, points: [0, 0, 100, 100], ...props };
        } else if (type === 'text') {
          return { ...baseShape, text: 'Test', fontSize: 16, fontFamily: 'Arial', ...props };
        }
        
        return { ...baseShape, ...props };
      };
      
      // Test 1: Create rectangle shape
      try {
        const rect = createShape('rectangle', { width: 150, height: 100 });
        const isValid = 
          rect.type === 'rectangle' &&
          rect.width === 150 &&
          rect.height === 100 &&
          rect.x === 100 &&
          rect.y === 100 &&
          rect.rotation === 0;
        
        suite.tests.push({
          name: 'Should create rectangle with correct properties',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should create rectangle with correct properties',
          passed: false,
          error: error.message
        });
      }
      
      // Test 2: Create circle shape
      try {
        const circle = createShape('circle', { radius: 75 });
        const isValid = 
          circle.type === 'circle' &&
          circle.radius === 75 &&
          circle.x === 100 &&
          circle.y === 100;
        
        suite.tests.push({
          name: 'Should create circle with correct properties',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should create circle with correct properties',
          passed: false,
          error: error.message
        });
      }
      
      // Test 3: Create line shape
      try {
        const line = createShape('line', { points: [0, 0, 200, 150] });
        const isValid = 
          line.type === 'line' &&
          Array.isArray(line.points) &&
          line.points.length === 4 &&
          line.points[2] === 200 &&
          line.points[3] === 150;
        
        suite.tests.push({
          name: 'Should create line with correct points',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should create line with correct points',
          passed: false,
          error: error.message
        });
      }
      
      // Test 4: Create text shape
      try {
        const text = createShape('text', { text: 'Hello Canvas', fontSize: 24 });
        const isValid = 
          text.type === 'text' &&
          text.text === 'Hello Canvas' &&
          text.fontSize === 24 &&
          text.fontFamily === 'Arial';
        
        suite.tests.push({
          name: 'Should create text with correct properties',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should create text with correct properties',
          passed: false,
          error: error.message
        });
      }
      
      // Test 5: Resize rectangle
      try {
        const rect = createShape('rectangle', { width: 100, height: 50 });
        await new Promise(resolve => setTimeout(resolve, 1));
        const resized = { ...rect, width: 200, height: 150, updatedAt: Date.now() };
        
        const isValid = 
          resized.width === 200 &&
          resized.height === 150 &&
          resized.x === rect.x &&
          resized.y === rect.y &&
          resized.updatedAt > rect.createdAt;
        
        suite.tests.push({
          name: 'Should resize rectangle correctly',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should resize rectangle correctly',
          passed: false,
          error: error.message
        });
      }
      
      // Test 6: Resize circle
      try {
        const circle = createShape('circle', { radius: 50 });
        await new Promise(resolve => setTimeout(resolve, 1));
        const resized = { ...circle, radius: 100, updatedAt: Date.now() };
        
        const isValid = 
          resized.radius === 100 &&
          resized.x === circle.x &&
          resized.y === circle.y &&
          resized.updatedAt > circle.createdAt;
        
        suite.tests.push({
          name: 'Should resize circle correctly',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should resize circle correctly',
          passed: false,
          error: error.message
        });
      }
      
      // Test 7: Move shape
      try {
        const rect = createShape('rectangle');
        await new Promise(resolve => setTimeout(resolve, 1));
        const moved = { ...rect, x: 300, y: 250, updatedAt: Date.now() };
        
        const deltaX = moved.x - rect.x;
        const deltaY = moved.y - rect.y;
        const isValid = 
          deltaX === 200 &&
          deltaY === 150 &&
          moved.width === rect.width &&
          moved.height === rect.height &&
          moved.updatedAt > rect.createdAt;
        
        suite.tests.push({
          name: 'Should move shape correctly',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should move shape correctly',
          passed: false,
          error: error.message
        });
      }
      
      // Test 8: Rotate shape
      try {
        const rect = createShape('rectangle');
        const rotated = { ...rect, rotation: 45, updatedAt: Date.now() };
        
        const isValid = 
          rotated.rotation === 45 &&
          rotated.x === rect.x &&
          rotated.y === rect.y &&
          rotated.width === rect.width &&
          rotated.height === rect.height;
        
        suite.tests.push({
          name: 'Should rotate shape correctly',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should rotate shape correctly',
          passed: false,
          error: error.message
        });
      }
      
      // Test 9: Calculate rectangle bounds
      try {
        const rect = createShape('rectangle', { x: 50, y: 100, width: 200, height: 150 });
        const bounds = {
          left: rect.x,
          top: rect.y,
          right: rect.x + rect.width,
          bottom: rect.y + rect.height,
          width: rect.width,
          height: rect.height
        };
        
        const isValid = 
          bounds.left === 50 &&
          bounds.top === 100 &&
          bounds.right === 250 &&
          bounds.bottom === 250 &&
          bounds.width === 200 &&
          bounds.height === 150;
        
        suite.tests.push({
          name: 'Should calculate rectangle bounds correctly',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should calculate rectangle bounds correctly',
          passed: false,
          error: error.message
        });
      }
      
      // Test 10: Calculate circle bounds
      try {
        const circle = createShape('circle', { x: 200, y: 200, radius: 50 });
        const bounds = {
          left: circle.x - circle.radius,
          top: circle.y - circle.radius,
          right: circle.x + circle.radius,
          bottom: circle.y + circle.radius,
          width: circle.radius * 2,
          height: circle.radius * 2
        };
        
        const isValid = 
          bounds.left === 150 &&
          bounds.top === 150 &&
          bounds.right === 250 &&
          bounds.bottom === 250 &&
          bounds.width === 100 &&
          bounds.height === 100;
        
        suite.tests.push({
          name: 'Should calculate circle bounds correctly',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should calculate circle bounds correctly',
          passed: false,
          error: error.message
        });
      }
      
      // Test 11: Point inside rectangle detection
      try {
        const rect = createShape('rectangle', { x: 100, y: 100, width: 200, height: 150 });
        const pointInside = { x: 200, y: 150 };
        const pointOutside = { x: 50, y: 50 };
        
        const isInside = 
          pointInside.x >= rect.x &&
          pointInside.x <= rect.x + rect.width &&
          pointInside.y >= rect.y &&
          pointInside.y <= rect.y + rect.height;
        
        const isOutside = !(
          pointOutside.x >= rect.x &&
          pointOutside.x <= rect.x + rect.width &&
          pointOutside.y >= rect.y &&
          pointOutside.y <= rect.y + rect.height
        );
        
        suite.tests.push({
          name: 'Should detect point inside/outside rectangle',
          passed: isInside && isOutside,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should detect point inside/outside rectangle',
          passed: false,
          error: error.message
        });
      }
      
      // Test 12: Point inside circle detection
      try {
        const circle = createShape('circle', { x: 200, y: 200, radius: 50 });
        const pointInside = { x: 210, y: 210 };
        const pointOutside = { x: 300, y: 300 };
        
        const distanceInside = Math.sqrt(
          Math.pow(pointInside.x - circle.x, 2) + 
          Math.pow(pointInside.y - circle.y, 2)
        );
        const distanceOutside = Math.sqrt(
          Math.pow(pointOutside.x - circle.x, 2) + 
          Math.pow(pointOutside.y - circle.y, 2)
        );
        
        const isInside = distanceInside <= circle.radius;
        const isOutside = distanceOutside > circle.radius;
        
        suite.tests.push({
          name: 'Should detect point inside/outside circle',
          passed: isInside && isOutside,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should detect point inside/outside circle',
          passed: false,
          error: error.message
        });
      }
      
      // Test 13: Shape ID uniqueness
      try {
        const shapes = [];
        for (let i = 0; i < 10; i++) {
          shapes.push(createShape('rectangle'));
          await new Promise(resolve => setTimeout(resolve, 1));
        }
        
        const ids = shapes.map(s => s.id);
        const uniqueIds = new Set(ids);
        
        suite.tests.push({
          name: 'Should generate unique IDs for shapes',
          passed: uniqueIds.size === 10,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should generate unique IDs for shapes',
          passed: false,
          error: error.message
        });
      }
      
      // Test 14: Shape timestamp validation
      try {
        const rect = createShape('rectangle');
        const now = Date.now();
        const timeDiff = Math.abs(now - rect.createdAt);
        
        const isValid = 
          rect.createdAt > 0 &&
          rect.updatedAt > 0 &&
          rect.createdAt === rect.updatedAt &&
          timeDiff < 1000; // Created within last second
        
        suite.tests.push({
          name: 'Should set valid timestamps on shape creation',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should set valid timestamps on shape creation',
          passed: false,
          error: error.message
        });
      }
      
      // Test 15: Shape property immutability on copy
      try {
        const original = createShape('rectangle', { width: 100, height: 50 });
        const copy = { ...original, width: 200 };
        
        const isValid = 
          original.width === 100 &&
          copy.width === 200 &&
          original.height === copy.height &&
          original.id === copy.id;
        
        suite.tests.push({
          name: 'Should copy shapes without mutating original',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should copy shapes without mutating original',
          passed: false,
          error: error.message
        });
      }
      
      // Test 16: Validate shape type detection
      try {
        const rect = createShape('rectangle');
        const circle = createShape('circle');
        const line = createShape('line');
        const text = createShape('text');
        const arrow = createShape('arrow');
        
        const hasCorrectTypes = 
          rect.type === 'rectangle' &&
          circle.type === 'circle' &&
          line.type === 'line' &&
          text.type === 'text' &&
          arrow.type === 'arrow';
        
        const hasTypeSpecificProps = 
          (rect.width !== undefined && rect.height !== undefined) &&
          (circle.radius !== undefined) &&
          (line.points !== undefined) &&
          (text.text !== undefined && text.fontSize !== undefined);
        
        suite.tests.push({
          name: 'Should correctly identify shape types and properties',
          passed: hasCorrectTypes && hasTypeSpecificProps,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should correctly identify shape types and properties',
          passed: false,
          error: error.message
        });
      }
      
      // Test 17: Shape update tracking
      try {
        const rect = createShape('rectangle');
        await new Promise(resolve => setTimeout(resolve, 10));
        const updated = { ...rect, x: 200, updatedAt: Date.now() };
        
        const isValid = 
          updated.updatedAt > rect.updatedAt &&
          updated.createdAt === rect.createdAt &&
          updated.id === rect.id;
        
        suite.tests.push({
          name: 'Should track shape updates with timestamps',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should track shape updates with timestamps',
          passed: false,
          error: error.message
        });
      }
      
      // Test 18: Multiple transformations
      try {
        const rect = createShape('rectangle', { x: 100, y: 100, width: 100, height: 50, rotation: 0 });
        
        // Move
        let transformed = { ...rect, x: 200, y: 150 };
        // Resize
        transformed = { ...transformed, width: 150, height: 100 };
        // Rotate
        transformed = { ...transformed, rotation: 90 };
        
        const isValid = 
          transformed.x === 200 &&
          transformed.y === 150 &&
          transformed.width === 150 &&
          transformed.height === 100 &&
          transformed.rotation === 90 &&
          transformed.id === rect.id;
        
        suite.tests.push({
          name: 'Should handle multiple transformations correctly',
          passed: isValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Should handle multiple transformations correctly',
          passed: false,
          error: error.message
        });
      }
      
      testResults.push(suite);
    }

    async function runIntegrationTests() {
      const suite = { name: 'Cross-Service Integration', tests: [] };
      
      // Test 1: Firebase modules integration
      try {
        const authApp = auth?.app;
        const firestoreApp = db?.app;
        const rtdbApp = realtimeDb?.app;
        const sameInstance = authApp === firestoreApp && firestoreApp === rtdbApp;
        
        suite.tests.push({
          name: 'All Firebase services should share same app instance',
          passed: sameInstance,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'All Firebase services should share same app instance',
          passed: false,
          error: error.message
        });
      }
      
      // Test 2: Configuration consistency
      try {
        const authConfig = auth?.config;
        const appOptions = auth?.app?.options;
        const hasRequiredConfig = 
          authConfig?.apiKey && 
          authConfig?.authDomain && 
          appOptions?.projectId;
        
        suite.tests.push({
          name: 'Firebase configuration should be complete',
          passed: Boolean(hasRequiredConfig),
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Firebase configuration should be complete',
          passed: false,
          error: error.message
        });
      }
      
      // Test 3: Health check integration
      try {
        const allServicesChecked = services.length === 5;
        const hasExpectedServices = 
          services.some(s => s.name.includes('Authentication')) &&
          services.some(s => s.name.includes('Firestore')) &&
          services.some(s => s.name.includes('Realtime Database')) &&
          services.some(s => s.name.includes('Hosting')) &&
          services.some(s => s.name.includes('OpenAI'));
        
        suite.tests.push({
          name: 'All expected services should be monitored',
          passed: allServicesChecked && hasExpectedServices,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'All expected services should be monitored',
          passed: false,
          error: error.message
        });
      }
      
      testResults.push(suite);
    }

    async function runDataValidationTests() {
      const suite = { name: 'Data Validation & Structure', tests: [] };
      
      // Test 1: Service status values
      try {
        const validStatuses = ['healthy', 'error', 'checking'];
        const allValid = services.every(s => validStatuses.includes(s.status));
        
        suite.tests.push({
          name: 'Service status values should be valid',
          passed: allValid,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Service status values should be valid',
          passed: false,
          error: error.message
        });
      }
      
      // Test 2: Service details structure
      try {
        const allHaveDetails = services.every(s => 
          Array.isArray(s.details) && s.details.length > 0
        );
        const detailsHaveStructure = services.every(s =>
          s.details.every(d => d.label && d.value)
        );
        
        suite.tests.push({
          name: 'Service details should have proper structure',
          passed: allHaveDetails && detailsHaveStructure,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Service details should have proper structure',
          passed: false,
          error: error.message
        });
      }
      
      // Test 3: Performance metrics
      try {
        const servicesWithResponseTime = services.filter(s =>
          s.details.some(d => d.label === 'Response Time')
        );
        const hasMetrics = servicesWithResponseTime.length > 0;
        
        suite.tests.push({
          name: 'Services should include performance metrics',
          passed: hasMetrics,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Services should include performance metrics',
          passed: false,
          error: error.message
        });
      }
      
      testResults.push(suite);
    }

    async function runUtilityTests() {
      const suite = { name: 'Browser & DOM Tests', tests: [] };
      
      // Test 1: localStorage availability
      try {
        const testKey = '_healthcheck_test';
        localStorage.setItem(testKey, 'test');
        const value = localStorage.getItem(testKey);
        localStorage.removeItem(testKey);
        
        suite.tests.push({
          name: 'localStorage should be available and functional',
          passed: value === 'test',
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'localStorage should be available and functional',
          passed: false,
          error: error.message
        });
      }
      
      // Test 2: Fetch API
      let fetchStart = Date.now();
      try {
        const response = await fetch('/healthcheck', { method: 'HEAD' });
        const duration = Date.now() - fetchStart;
        
        suite.tests.push({
          name: 'Fetch API should work (self-check)',
          passed: response.ok,
          duration
        });
      } catch (error) {
        suite.tests.push({
          name: 'Fetch API should work (self-check)',
          passed: false,
          error: error.message
        });
      }
      
      // Test 3: Date/Time utilities
      try {
        const now = Date.now();
        const date = new Date();
        const isValidTimestamp = now > 1600000000000 && now < 2000000000000;
        const isValidDate = date instanceof Date && !isNaN(date.getTime());
        
        suite.tests.push({
          name: 'Date and time utilities should work correctly',
          passed: isValidTimestamp && isValidDate,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Date and time utilities should work correctly',
          passed: false,
          error: error.message
        });
      }
      
      // Test 4: DOM manipulation
      try {
        const servicesDiv = document.getElementById('services');
        const testDiv = document.createElement('div');
        testDiv.id = '_test_element';
        document.body.appendChild(testDiv);
        const retrieved = document.getElementById('_test_element');
        document.body.removeChild(testDiv);
        
        suite.tests.push({
          name: 'DOM manipulation should work correctly',
          passed: servicesDiv !== null && retrieved !== null,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'DOM manipulation should work correctly',
          passed: false,
          error: error.message
        });
      }
      
      // Test 5: JSON parsing
      try {
        const testObj = { test: 'value', number: 123, nested: { key: 'val' } };
        const jsonString = JSON.stringify(testObj);
        const parsed = JSON.parse(jsonString);
        const isEqual = parsed.test === testObj.test && 
                       parsed.number === testObj.number &&
                       parsed.nested.key === testObj.nested.key;
        
        suite.tests.push({
          name: 'JSON stringify/parse should work correctly',
          passed: isEqual,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'JSON stringify/parse should work correctly',
          passed: false,
          error: error.message
        });
      }
      
      // Test 6: Array operations
      try {
        const arr = [1, 2, 3, 4, 5];
        const filtered = arr.filter(n => n > 2);
        const mapped = arr.map(n => n * 2);
        const reduced = arr.reduce((sum, n) => sum + n, 0);
        
        const result = 
          filtered.length === 3 &&
          mapped[0] === 2 &&
          reduced === 15;
        
        suite.tests.push({
          name: 'Array methods should work correctly',
          passed: result,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Array methods should work correctly',
          passed: false,
          error: error.message
        });
      }
      
      // Test 7: String operations
      try {
        const str = 'CollabCanvas Health Check';
        const hasIncludes = str.includes('Health');
        const hasStartsWith = str.startsWith('Collab');
        const hasEndsWith = str.endsWith('Check');
        const splitWorks = str.split(' ').length === 3;
        
        suite.tests.push({
          name: 'String methods should work correctly',
          passed: hasIncludes && hasStartsWith && hasEndsWith && splitWorks,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'String methods should work correctly',
          passed: false,
          error: error.message
        });
      }
      
      // Test 8: Promise handling
      let promiseStart = Date.now();
      try {
        await new Promise(resolve => setTimeout(resolve, 10));
        const duration = Date.now() - promiseStart;
        
        suite.tests.push({
          name: 'Promise and async/await should work',
          passed: duration >= 10 && duration < 100,
          duration
        });
      } catch (error) {
        suite.tests.push({
          name: 'Promise and async/await should work',
          passed: false,
          error: error.message
        });
      }
      
      // Test 9: Console availability
      try {
        const hasConsole = typeof console !== 'undefined' &&
                          typeof console.log === 'function' &&
                          typeof console.error === 'function';
        
        suite.tests.push({
          name: 'Console API should be available',
          passed: hasConsole,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Console API should be available',
          passed: false,
          error: error.message
        });
      }
      
      // Test 10: Error handling
      try {
        let errorCaught = false;
        try {
          throw new Error('Test error');
        } catch (e) {
          errorCaught = e.message === 'Test error';
        }
        
        suite.tests.push({
          name: 'Error handling should work correctly',
          passed: errorCaught,
          duration: 0
        });
      } catch (error) {
        suite.tests.push({
          name: 'Error handling should work correctly',
          passed: false,
          error: error.message
        });
      }
      
      testResults.push(suite);
    }

    function displayTestResults() {
      const resultsDiv = document.getElementById('test-results');
      
      let totalTests = 0;
      let passedTests = 0;
      let failedTests = 0;
      
      testResults.forEach(suite => {
        suite.tests.forEach(test => {
          totalTests++;
          if (test.passed) passedTests++;
          else failedTests++;
        });
      });
      
      let html = '';
      
      // Summary
      const summaryClass = failedTests === 0 ? 'all-passed' : 'some-failed';
      html += `<div class="test-summary ${summaryClass}">`;
      if (failedTests === 0) {
        html += `✅ All Tests Passed: ${passedTests}/${totalTests}`;
      } else {
        html += `⚠️ Tests: ${passedTests} passed, ${failedTests} failed out of ${totalTests}`;
      }
      html += `</div>`;
      
      // Test suites
      testResults.forEach(suite => {
        const suitePassed = suite.tests.filter(t => t.passed).length;
        const suiteTotal = suite.tests.length;
        
        html += `<div class="test-suite">`;
        html += `<div class="test-suite-header">`;
        html += `<span>${suite.name}</span>`;
        html += `<span style="font-size: 14px; color: #718096;">${suitePassed}/${suiteTotal} passed</span>`;
        html += `</div>`;
        
        suite.tests.forEach(test => {
          const statusClass = test.passed ? 'passed' : 'failed';
          const badge = test.passed ? 'PASS' : 'FAIL';
          
          html += `<div class="test-case ${statusClass}">`;
          html += `<div>`;
          html += `<div>${test.name}</div>`;
          if (test.duration !== undefined) {
            html += `<div style="font-size: 12px; color: #718096; margin-top: 4px;">Duration: ${test.duration}ms</div>`;
          }
          if (test.note) {
            html += `<div style="font-size: 12px; color: #4a5568; margin-top: 4px; font-style: italic;">${test.note}</div>`;
          }
          if (test.error) {
            html += `<div class="test-error">Error: ${test.error}</div>`;
          }
          html += `</div>`;
          html += `<span class="test-badge ${statusClass}">${badge}</span>`;
          html += `</div>`;
        });
        
        html += `</div>`;
      });
      
      resultsDiv.innerHTML = html;
    }

    window.runTests = runTests;
  </script>
</body>
</html>

